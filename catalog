#!/usr/bin/perl -w
    eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
        if 0; #$running_under_some_shell

# $Id: $

# MEMO
#
# ora fa un find : 1. directory [NO: 2. time_lapse]
# 1. solo le directory
# 1a. no files
# 2. solo aggiornati
#

# TODO:
#
# leggere il file di config | OK
# cancellare $time_lapse | OK
# NO: valore iniziale di $time_lapse o eliminazione direttiva in wanted() | OK
# NO: valutare l'uso di epoch in tab.directory
# togliere eoch dal db
#
# aggiungere una tabella per i file + exif
#
use strict;
use File::Find ();
use File::stat;
use DBI;
# use Filesys::Df;
use Digest::MD5 qw(md5_hex);


# use Image::ExifTool;

# caricati ma non utilizzati... verranno comodi!!!
# use DateTime;
# use DateTime::Format::MySQL;


sub wanted;
sub InsertVolumes;
sub InsertDir;

my $label;
# my $dir;
my @dirs = ();

# deve essere globale perchè all'interno di wanted!!!! BAH!!!
my @sql=(); # l'array del sql privo di "insert into directory "

my $catalog = 'ste';
my $schema = 'catalog';

#
# lettura del file di configurazione
#
open FH, "catalog.conf" or die "can't open conf";

#    print "label: xxx\n";
#    print "+dir01\n";
#    print "+dir02\n";

while(<FH>) {
  $label = $1 if (m/label: (.*)$/);
  if (m/^\+(.*)/) {
    push(@dirs, $1);
  }
}
close FH;

#
# solo x debug, riscrive il conf
#
if (1) {
  print "label: ".$label."\n";
  foreach my $d (@dirs) {
    print $d."\n";
  }
}


die ("label") unless ( $label );
#
# TODO: verifica anche su @dirs...
#

my $dbh = DBI->connect("DBI:mysql:database=catalog;host=localhost",'ste','ste');

my $opt_d=0; # debug


DeleteOldRecords( $label );

my $vid = InsertVolumes($label);


foreach my $d (@dirs) {
  @sql = ();  
  print "directory->".$d."\n";
  InsertDir( $d, $vid );
}

  print ".3.\n" if ($opt_d);
  $dbh->disconnect();


  # -M  Script start time minus file modification time, in days.
  # $^T : script starting time 

exit;




#
# va sempre in sovrascrittura
#
sub DeleteOldRecords 
  {
    my $volname = shift(@_);
    my $vol_id;

    # verifica dell'esitenza
    ## my $sqldel1 = "select count(*) as c from directory where volid = $vol_id";

    my $sql = "select id from volumes where volname = ?";
    my $sth2 = $dbh->prepare($sql);
    $sth2->execute($volname);

    while ( my @row = $sth2->fetchrow_array ) {
      $vol_id = $row[0];
      print $vol_id, "\n";
    }


    # con una FK ...
    my $sqldel3 = "delete from images where did in (select volid from directory  ?";
    $sth2 = $dbh->prepare($sqldel3);
    $sth2->execute($vol_id);

    # cancellazione
    my $sqldel2 = "delete from directory where volid = ?";
    $sth2 = $dbh->prepare($sqldel2);
    $sth2->execute($vol_id);
    
    # con una FK passerebbe tutto
    my $sqldel3 = "delete from volumes where id = ?";
    $sth2 = $dbh->prepare($sqldel3);
    $sth2->execute($vol_id);

  }



sub InsertVolumes
  {
      my $vol_name = shift(@_);

      my $found=0;
      my $vol_id ;
      my $time_lapse; # == ????

    #
    # cerca l'occrrenza esatta
    #
    my $sth = $dbh->prepare("SELECT id, last FROM volumes where volname=?");
    $sth->execute($vol_name);
    while (my $ref = $sth->fetchrow_hashref()) {
      print "Found a row: id = $ref->{'last'}\n";
      $vol_id=$ref->{'id'};
      $time_lapse=$^T-$ref->{'last'};
      # delta_days();
      $found=1;
    }
    $sth->finish();
    
    

#     #
#     # se non lo trova cerca il soundex()
#     #
#     if (!$found) {
#       my $sth = $dbh->prepare("SELECT id, last FROM volumes where soundex(volname)=soundex(?)");
#       $sth->execute($vol_name);
#       while (my $ref = $sth->fetchrow_hashref()) {
# 	print "Forse intendevi $ref->{'last'} ??\n";
# 	$found=1;
# 	$vol_id=$ref->{'id'};
# 	$time_lapse=$^T-$ref->{'last'};
#       }
#       $sth->finish();
#       if ($found) {
# 	$dbh->disconnect();
# 	die q( TODO: per ora esce, però è possibile gestirlo! );
#       }
#    }
    
    #
    # se non lo trova _ancora_ inserisce nuovo 
    #
    if (!$found) {
      # TODO: transazionale ???
      my $sth = $dbh->prepare("insert into volumes (volname, last) values (?, now())");
      $sth->execute($vol_name);
      my $rv = $dbh->last_insert_id($catalog, $schema, 'volumes', 'id');
      $vol_id=$rv;
      $time_lapse = 1000; # TODO: penso che questo riduca l'efficienza della sub wanted()
      $sth->finish();
    }

	{
    my $dsp = diskSpace();    
    my $sth = $dbh->prepare("update volumes set available=? where id=?");
	  $sth->execute($dsp, $vol_id);
}
    return $vol_id;
  }



sub InsertDir() 
{

  my ($starting_dir, $vol_id) = @_;
  

  # questa verifica è troppo tardi: 
  # ha già inserito nel db... 
  # a meno di nn farlo transazionale
  die ("dir non esistente??") unless ( $starting_dir && -d $starting_dir );
  die ("vid??") unless ( $vol_id );


  # for the convenience of &wanted calls, including -eval statements:
  use vars qw/*name *dir *prune/;
  *name   = *File::Find::name;
  *dir    = *File::Find::dir;
  *prune  = *File::Find::prune;

  
  # 
  # questo lo lascio... in realtà non riesco 
  # a cancellare i vecchi record. 
  # con una FK dovrei riuscirci...
  #
  my $sqlstr = "insert into basedir (base_dir) values (?)";
  my $sth = $dbh->prepare($sqlstr);
  $sth->execute($starting_dir);
  my $basedir_id = $dbh->last_insert_id($catalog, $schema, 'volumes', 'id');


  print ".1.\n" if ($opt_d);
  # Traverse desired filesystems
  File::Find::find({wanted => \&wanted}, $starting_dir);

  print ".2.\n" if ($opt_d);
  foreach my $s (@sql) {

    # proposta: mantiene i record ma li "rinomina"
    # "update directory set oldvolid = volid, volid = NULL";
    my $sqlstr = "insert into directory ".$s;
    my $sth = $dbh->prepare($sqlstr);
    $sth->execute($vol_id, $starting_dir, $basedir_id);
    
    #
    InsertImage($starting_dir, $basedir_id);
    
    # print $sqlstr;
    # TODO: update ... SET dir = substr(dir, length(base_dir)) where  vol_id = $vol_id 
  }
  

}


#
#
#
sub InsertImage {
	my ($dirname, $did) = @_;
	
	my $sql=qq(insert into image (filename, md5, dir) values (?,?,$did));
	my $sth = $dbh->prepare($sql);
	while(<$dirname/*>) {
		next if ( -d $_);
		$sth->execute($_, md5_hex($_));
		printf "%s - %s\n", $_, md5_hex($_);
	}
}




#
#
#
my @fields = qw (FileName
DateTimeOriginal   
Lens               
HyperfocalDistance 
ExposureCompensation
ShutterSpeed       
MeteringMode       
SerialNumber       
ISO                
ApertureValue      
FlashFunction      
ExposureProgram    
Flash              
Keywords           
Rating             
FNumber            
FocalLength        
ExposureMode       
FileSize
Model              
Software      );     



sub InsertExif {
my $exif = new Image::ExifTool;
}

#
# funzioni di utilità
#
sub escape {
    my $s = shift;
    $s =~ s/(['"])/$1$1/g;
    return $s;
}

sub diskSpace {
	my $os = $^O;
	my $retval = 0;

	if ($os =~ m/Win/) {
		my @space = qx(dir /-C .);
		my $r = pop(@space);
		my $MB = 1024*1024;
		
	 $retval = $1 if ($r =~ m/(\d+) byte disponibili/);
	 $retval /= $MB;
		
                
	} elsif ($os =~ m/darwin/) {
		# TODO
                # df -k
		$retval = 0;
	} else {
            $retval = 0;
        }
	return $retval;

}


#
# MVC mia nonna... crea parte della str sql qui
# TODO: Bleah
#
sub wanted {
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks);
    
# non tutte le variabili sono valorizzate, come mai???
    (($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = lstat($_)) &&
	-d _ 
##	&& (int(-M _) < $time_lapse)
	&& push(@sql, sprintf("(volid, base_dir, bd_id, dir) values (?, ?, ?, '%s/%s' );", 
		 escape($dir), escape($_) )) if (!($dir =~ m/Previews\.lrdata/i || $dir =~ m/recycler/i || $dir =~ m/system volume information/i));
# ---- qui ancora con epoch...
#	&& push(@sql, sprintf("(volid, base_dir, bd_id, dir, name, epoch) values (?, ?, ?, '%s','%s', %f);", 
#		 $dir, $_, $^T+-M _)) if (!($dir =~ m/recycler/i || $dir =~ m/system volume information/i));
}

#
